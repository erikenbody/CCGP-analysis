from pathlib import Path

rule get_vcf_samples:
    input:
        vcf = ancient("results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz"),
    output:
        samps = "results/{refGenome}/algatr/{prefix}.samps4coords.txt"
    shell:
        "bcftools query -l {input.vcf} > {output.samps}"

rule create_coords_sheet:
    input:
        vcf = ancient("results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz"),
        samps = "results/{refGenome}/algatr/{prefix}.samps4coords.txt"
    output:
        samps_w_coord = "results/{refGenome}/algatr/{prefix}.coords.txt",
        exclude_samps = "results/{refGenome}/algatr/{prefix}.no_coords.txt"
    conda:
        "envs/mongo.yml"
    params:
        project_id = "{prefix}",
        ref_genome = "{refGenome}",
        sample_id = config["sample_id"]
    script:
        "scripts/create_coord_sheet_revised.py"

rule remove_samps_no_coords:
    input:
        vcf = "results/{refGenome}/CCGP/{prefix}_pruned_mil.vcf.gz",
        vcfidx = "results/{refGenome}/CCGP/{prefix}_pruned_mil.vcf.gz.csi",
        
        excluded_samps = "results/{refGenome}/algatr/{prefix}.no_coords.txt"
    output:
        filtered_no_coords = "results/{refGenome}/algatr/{prefix}_complete_coords_pruned_mil.vcf.gz",
        filtidx_no_coords = "results/{refGenome}/algatr/{prefix}_complete_coords_pruned_mil.vcf.gz.csi"
    conda:
        "envs/shapeit.yml"
    shell:
        """
        if [ ! -s {input.excluded_samps} ]; then
            cp {input.vcf} {output.filtered_no_coords}
            cp {input.vcfidx} {output.filtidx_no_coords}
        else
            bcftools view -S ^{input.excluded_samps} -f .,PASS {input.vcf} -a -U -O u | bcftools +fill-tags -Ou |
            bcftools view -m2 -e 'AF==0 | ref="N" | ALT="."' -O z -o {output.filtered_no_coords}
            bcftools index {output.filtered_no_coords}
        fi
        """

rule remove_samps_no_coords_full:
    input:
        vcf = "results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz",
        vcfidx = "results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz.csi",
        excluded_samps = "results/{refGenome}/algatr/{prefix}.no_coords.txt"
    output:
        filtered_no_coords = "results/{refGenome}/algatr/{prefix}_complete_coords_annotated.vcf.gz",
        filtidx_no_coords = "results/{refGenome}/algatr/{prefix}_complete_coords_annotated.vcf.gz.csi"
    conda:
        "envs/shapeit.yml"
    shell:
        """
        if [ ! -s {input.excluded_samps} ]; then
            cp {input.vcf} {output.filtered_no_coords}
            cp {input.vcfidx} {output.filtidx_no_coords}
        else
            bcftools view -S ^{input.excluded_samps} -f .,PASS {input.vcf} -a -U -O u | bcftools +fill-tags -Ou |
            bcftools view -m2 -e 'AF==0 | ref="N" | ALT="."' -O z -o {output.filtered_no_coords}
            bcftools index {output.filtered_no_coords}
        fi
        """

rule plink_pca:
    """
    Call plink PCA. Needed for input to RDA analysis
    """
    input:
        vcf = "results/{refGenome}/CCGP/{prefix}_pruned_mil.vcf.gz",
    params:
        prefix = "results/{refGenome}/algatr/{prefix}"
    output: 
        eigenvec = "results/{refGenome}/algatr/{prefix}.eigenvec",
        eigenval = "results/{refGenome}/algatr/{prefix}.eigenval",
    conda:
        "envs/plink.yml"
    resources:
        mem_mb = lambda wildcards, attempt: attempt * 2000
    shell:
        """
        plink2 --vcf {input.vcf} --pca 10 --out {params.prefix} --allow-extra-chr --autosome-num 95 --const-fid --bad-freqs
        """
        
rule algatr_tess:
    """
    call algatr tess 
    """
    input:
        #vcf = ancient("results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz"),
        #pruned6 = ancient("results/{refGenome}/CCGP/{prefix}_annotated_pruned_0.6.vcf.gz"),
        #pruned = "results/{refGenome}/CCGP/{prefix}_pruned_mil.vcf.gz", #this doesnt have samples with coordinates removed included
        pruned = "results/{refGenome}/algatr/{prefix}_complete_coords_pruned_mil.vcf.gz",#vcf with samples with missing coordinates removed
        prunedix = "results/{refGenome}/algatr/{prefix}_complete_coords_pruned_mil.vcf.gz.csi",
        #coords = "results/{refGenome}/QC/{prefix}.coords.txt",
        coords2 = "results/{refGenome}/algatr/{prefix}.coords.txt" #this should exist when it is made
    params:
        species = config['final_prefix'],
        data_path = "results/{refGenome}/",
        rmislands = "true",
        kvals = "1:10",
        output_path = "results/{refGenome}/algatr/"
    resources:
        mem_mb = lambda wildcards, attempt: attempt * 2000
    log:
        "logs/{refGenome}/algatr/{prefix}_tess.txt"
    benchmark:
        "results/{refGenome}/benchmarks/{prefix}_TESS.benchmark.txt",
    output: 
    # Exported files are as follows:
        tess1 = "results/{refGenome}/algatr/{prefix}_TESS_qmatrix.csv",
        #tess3 = "results/{refGenome}/algatr/{prefix}_TESS_bestK_krigadmix.tif",
        tess4 = "results/{refGenome}/algatr/{prefix}_TESS_xval.csv",
        tess5 = "results/{refGenome}/algatr/{prefix}_TESS_peakRAM.csv"
    conda:
        "envs/tess.yml"
    script:
        "scripts/TESS_cloud.R" 

rule generate_index:
    input:
        vcf = ancient("results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz")
        
    output:
        csi = "results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz.csi"
    shell:
        "bcftools index {input.vcf}"

rule seperate_vcf:
    input:
        #vcf = ancient("results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz"),
        fai = "results/{refGenome}/data/genome/{refGenome}.fna.fai",
        #csi = "results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz.csi",
        vcf = "results/{refGenome}/algatr/{prefix}_complete_coords_annotated.vcf.gz",
        csi = "results/{refGenome}/algatr/{prefix}_complete_coords_annotated.vcf.gz.csi"
    output:
        scaf = "results/{refGenome}/algatr/subsets/{prefix}_{scaff}_annotated.vcf.gz"
        
    log:
        "logs/{refGenome}/algatr/subsets/{prefix}_{scaff}.scaff.txt"
    shell:
         "bcftools view -r {wildcards.scaff} {input.vcf} -Oz -o {output.scaf}"

rule algatr_RDA:
    """
    call algatr tess 
    """
    input:
        #vcf = ancient("results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz"),
        #pruned6 = ancient("results/{refGenome}/CCGP/{prefix}_annotated_pruned_0.6.vcf.gz"),
        scaf = "results/{refGenome}/algatr/subsets/{prefix}_{scaff}_annotated.vcf.gz",
        eigenvec = "results/{refGenome}/algatr/{prefix}.eigenvec",
        coords = "results/{refGenome}/algatr/{prefix}.coords.txt"
    params:
        species = config['final_prefix'],
        data_path = "results/{refGenome}/",
        output_path = "results/{refGenome}/algatr/subsets/RDA/{scaff}/",
        rmislands = "false",
        pruned = "false",
        impute = "simple",
        kvals = "1:10",
        correctGEO = "false",
        correctPC = "results/{refGenome}/algatr/{prefix}.eigenvec",
        nPC = 10,
        model = "full", #TECHINALLY SNAKEMAKE WOULDNT WORK IF I CHANGE THIS
        sig = 0.01, # only for outlier_method = "p"
        z = 3, # only for outlier_method = "z"
        Pin = 0.05,
        R2permutations = 1000,
        R2scope = "true",
        p_adj = "fdr", # only if outlier_method = "p"
        save_impute = "true",
        intervals = "true",
        scaff = "{scaff}"
    resources:
        mem_mb = lambda wildcards, attempt: attempt * 2000
    log:
        "logs/{refGenome}/algatr/subsets/{prefix}_{scaff}.RDA.txt"
    benchmark:
        "results/{refGenome}/benchmarks/subsets/{prefix}_{scaff}.RDA.benchmark.txt",
    output: 
        #impute = "results/{refGenome}/algatr/{prefix}_imputed_structure.txt", #only gets made if imputing is done with snmf
        impute = "results/{refGenome}/algatr/subsets/RDA/{scaff}/{prefix}_imputed_simple.txt", 
        #anova = "results/{refGenome}/algatr/subsets/RDA/{scaff}/{prefix}_RDA_anova_best.csv", #uncomment this later, but this file isnt appearing
        #cortest = "results/{refGenome}/subsets/RDA/{scaff}/{prefix}_RDA_cortest_best.csv",
        #RDA_outliers = "results/{refGenome}/subsets/RDA/{scaff}/{prefix}_RDA_outliers_best_rdadapt.csv",
        #sp_RDA_outliers = "results/{refGenome}/subsets/RDA/{scaff}/{prefix}_RDA_outliers_best_Zscores.csv",
        #peakRAM = "results/{refGenome}/subsets/RDA/{scaff}/{prefix}_RDA_peakRAM.csv",
    conda:
        "envs/rda.yml"
    script:
        "scripts/RDA_cloud.R"

rule algatr_RDA_pruned:
    """
    call algatr tess on a pruned dataset
    """
    input:
        #vcf = "results/{refGenome}/CCGP/{prefix}_pruned_mil.vcf.gz",
        vcf = "results/{refGenome}/algatr/{prefix}_complete_coords_pruned_mil.vcf.gz",
        prunedix = "results/{refGenome}/algatr/{prefix}_complete_coords_pruned_mil.vcf.gz.csi",
        eigenvec = "results/{refGenome}/algatr/{prefix}.eigenvec",
        coords = "results/{refGenome}/algatr/{prefix}.coords.txt"
    params:
        species = config['final_prefix'],
        data_path = "results/{refGenome}/",
        output_path = "results/{refGenome}/algatr/",
        rmislands = "false",
        pruned = "true",
        impute = "simple",
        kvals = "1:10",
        correctGEO = "false",
        correctPC = "results/{refGenome}/algatr/{prefix}.eigenvec",
        nPC = 10,
        model = "full", #TECHINALLY SNAKEMAKE WOULDNT WORK IF I CHANGE THIS
        sig = 0.01, # only for outlier_method = "p"
        z = 3, # only for outlier_method = "z"
        Pin = 0.05,
        R2permutations = 1000,
        R2scope = "true",
        p_adj = "fdr", # only if outlier_method = "p"
        save_impute = "true",
        intervals = "true",
        scaff = "NA"
    resources:
        mem_mb = lambda wildcards, attempt: attempt * 2000
    log:
        log = "logs/{refGenome}/algatr/{prefix}.RDA.txt"
    benchmark:
        "results/{refGenome}/benchmarks/{prefix}.RDA.benchmark.txt",
    output: 
        #impute = "results/{refGenome}/algatr/{prefix}_imputed_structure.txt", #only gets made if imputing is done with snmf
        impute = "results/{refGenome}/algatr/{prefix}_imputed_simple.txt", 
        #anova = "results/{refGenome}/algatr/subsets/RDA/{scaff}/{prefix}_RDA_anova_best.csv", #uncomment this later, but this file isnt appearing
        #cortest = "results/{refGenome}/subsets/RDA/{scaff}/{prefix}_RDA_cortest_best.csv",
        #RDA_outliers = "results/{refGenome}/subsets/RDA/{scaff}/{prefix}_RDA_outliers_best_rdadapt.csv",
        #sp_RDA_outliers = "results/{refGenome}/subsets/RDA/{scaff}/{prefix}_RDA_outliers_best_Zscores.csv",
        #peakRAM = "results/{refGenome}/subsets/RDA/{scaff}/{prefix}_RDA_peakRAM.csv",
    conda:
        "envs/rda.yml"
    script:
        "scripts/RDA_cloud.R"



rule shapeit:
    input:
        scaf = "results/{refGenome}/algatr/subsets/{prefix}_{scaff}_annotated.vcf.gz",
        #csi = "results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz.csi",
        #vcf = ancient("results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz"),
        vcf = "results/{refGenome}/algatr/{prefix}_complete_coords_annotated.vcf.gz",
        csi = "results/{refGenome}/algatr/{prefix}_complete_coords_annotated.vcf.gz.csi"
    output:
        haplo = "results/{refGenome}/algatr/haplotypes/{prefix}_{scaff}_phased.bcf"
    conda:
        "envs/shapeit.yml"
    log:
        stderr = "logs/{refGenome}/algatr/{prefix}_{scaff}_phased.err",
        stdout = "logs/{refGenome}/algatr/{prefix}_{scaff}_phased.out"
    shell:
        #"shapeit4 --input {input.csi} --map {wildcards.scaf} --regions --output {output.haplo}" 
        """
        bcftools index -f {input.scaf}
        SHAPEIT5_phase_common --input {input.scaf} --region {wildcards.scaff} --output {output.haplo} --thread 8 > {log.stdout} 2> {log.stderr}
        """

rule concat_shapeit:
    input:
        haplo = expand("results/{{refGenome}}/algatr/haplotypes/{{prefix}}_{scaff}_phased.bcf", scaff=get_scaffolds(fai))
    output:
        haplo = "results/{refGenome}/algatr/{prefix}_shapeit5_phased.bcf"
    conda:
        "envs/shapeit.yml"
    shell:
        "bcftools concat -O z -o {output.haplo} {input.haplo}"

def get_k(wc):
    pops = checkpoints.distinguish_populations.get(**wc).output[1]
    k_values = []
    
    pops_dir = Path(pops)
    
    
    if pops_dir.is_dir():
        
        files = [file.name for file in pops_dir.iterdir() if file.is_file()]
        
        k_values = [file.split("_")[1].split(".")[0] for file in files if file.split("_")[1].split(".")[0].isdigit()]
    out = [*expand("results/{refGenome}/algatr/{prefix}_populations/population_{k}.txt", **wc, k=k_values),
        *expand("results/{refGenome}/algatr/{prefix}_population_vcf/population_{k}.vcf.gz.csi", **wc, k=k_values),
        *expand("results/{refGenome}/algatr/{prefix}_population_pi/pi_population_{k}.csv", **wc, k=k_values),
        *expand("results/{refGenome}/algatr/{prefix}_roh/population_{k}.roh.gz", **wc, k=k_values),
        *expand("results/{refGenome}/algatr/{prefix}_roh/population_{k}.rg.roh", **wc, k=k_values),
        *expand("results/{refGenome}/algatr/{prefix}_merged_roh/population_{k}.rg.roh", **wc, k=k_values),
        *expand("results/{refGenome}/algatr/{prefix}_filtered_population_{k}.froh", **wc, k=k_values),
        *expand("results/{refGenome}/algatr/{prefix}_filtered_population_{k}_top.froh", **wc, k=k_values)
    ]
    
    return out
    
checkpoint distinguish_populations:
    input:
        matrix = "results/{refGenome}/algatr/{prefix}_TESS_qmatrix.csv"
    output:
        pops_done = "results/{refGenome}/algatr/{prefix}_populations-done.txt",
        outdir = directory("results/{refGenome}/algatr/{prefix}_populations")
        
    conda:
        "envs/assign_pops.yml"
    params:
        project_id = "{prefix}",
        ref_genome = "{refGenome}",
        manual_k_assignment = "NA",
        threshold_qval = 0.80
    script:
        "scripts/population_assignment.py"
    
rule bcf_populations:
    input:
        pops = "results/{refGenome}/algatr/{prefix}_populations/population_{k}.txt",
        csi = "results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz.csi",
        vcf = ancient("results/{refGenome}/CCGP/{prefix}_annotated.vcf.gz"),
        pops_done = ancient("results/{refGenome}/algatr/{prefix}_populations-done.txt")
    output:
        pop_vcf = "results/{refGenome}/algatr/{prefix}_population_vcf/population_{k}.vcf.gz",
        index = "results/{refGenome}/algatr/{prefix}_population_vcf/population_{k}.vcf.gz.csi"
    conda:
        "envs/shapeit.yml"
    shell:
        """
        bcftools view -S {input.pops} -Ou -a -U {input.vcf} | bcftools +fill-tags -Ou |
        bcftools view -m2 -e 'AF==0 | ref="N" | ALT="."' -O z -o {output.pop_vcf}
        bcftools index {output.pop_vcf}
        """

rule pi_populations:
    input:
        pop_vcf = "results/{refGenome}/algatr/{prefix}_population_vcf/population_{k}.vcf.gz",
        bed = "results/{refGenome}/{prefix}_callable_sites.bed"
    output:
        pi = "results/{refGenome}/algatr/{prefix}_population_pi/pi_population_{k}.csv"
    conda:
        "envs/pi.yaml"
    params:
        project_id = "{prefix}",
        ref_genome = "{refGenome}",
        k_value = "{k}"
    script:
        "scripts/calculate_pi.py"


rule roh_pop:
    input:
        pop_vcf = ancient("results/{refGenome}/algatr/{prefix}_population_vcf/population_{k}.vcf.gz"),
    output:
        roh = "results/{refGenome}/algatr/{prefix}_roh/population_{k}.roh.gz",
        rg = "results/{refGenome}/algatr/{prefix}_roh/population_{k}.rg.roh"
    conda:
        "envs/roh.yml"
    resources:
       mem_mb = 128000,
       threads = 10
    shell:
        """
        bcftools roh --threads 10 -G30 -Oz -o {output.roh} {input.pop_vcf}
        zgrep RG {output.roh} > {output.rg}
        """

rule merge_roh:
    input:
        rg = "results/{refGenome}/algatr/{prefix}_roh/population_{k}.rg.roh"
    output:
        merged_rg = "results/{refGenome}/algatr/{prefix}_merged_roh/population_{k}.rg.roh"
    conda:
        "envs/roh.yml"
    params:
        gap_size = 10000
    script:
        "scripts/merge_roh.py"


rule froh_2:
    input:
        rg = ancient("results/{refGenome}/algatr/{prefix}_roh/population_{k}.rg.roh"),
        fai = ancient("results/{refGenome}/data/genome/{refGenome}.fna.fai"),
    output:
        froh = "results/{refGenome}/algatr/{prefix}_filtered_population_{k}.froh",
        top = "results/{refGenome}/algatr/{prefix}_filtered_population_{k}_top.froh"
    conda:
        "envs/froh.yml"
    params:
        population = "{k}",
        interval_width = 25
    script:
        "scripts/froh.py"

rule get_k_files:
    # dummy rule to get all of the files split by k pops
    input: get_k
    output: touch("results/{refGenome}/algatr/{prefix}/k.done")




        
rule get_chromosome_names:
    input:
        contigs = "results/{refGenome}/algatr/{prefix}_contigs.tsv"
    output:
        renamed = "results/{refGenome}/algatr/{prefix}_chromosome_names.txt"
    conda:
        "envs/assign_pops.yml"
    params:
        project_id = "{prefix}"
    script:
        "scripts/get_chromosome_names.py"

# This is good.
rule rename_chromosomes:
    input:
        #renamed = "results/{refGenome}/algatr/{prefix}_chromosome_names.txt",
        #snp_vcf = "results/{refGenome}/{prefix}_clean_snps.vcf.gz",
        fai = "results/{refGenome}/data/genome/{refGenome}.fna.fai"
    output:
        #renamed_snp_vcf = "results/{refGenome}/algatr/{prefix}_renamed_clean_snps.vcf.gz",
        chrom_names = "results/{refGenome}/CCGP/plink/{prefix}_GONE_contigs.txt"
    conda:
        "envs/roh.yml"
    params:
        chrom_num = 10
    shell:
        '''
        awk 'NR<={params.chrom_num} {{print $1}}' {input.fai} > {output.chrom_names} 
        '''

rule annotate_vcf:
    '''
    Generates an annotated pruned vcf to be used for GONE
    '''
    input:
        vcf = "results/{refGenome}/CCGP/{prefix}_pruned_mil.vcf.gz",
    output:
        vcf_ap = "results/{refGenome}/CCGP/plink/{prefix}_annotated_pruned.vcf.gz"
    conda:
        "envs/roh.yml"
    shell:
        """
        bcftools annotate --set-id '%CHROM\_%POS\_%REF\_%FIRST_ALT' -Oz -o {output.vcf_ap} {input.vcf}
        """

rule GONE_vcf:
    input:
        chrom_names = "results/{refGenome}/CCGP/plink/{prefix}_GONE_contigs.txt",
        vcf_ap = "results/{refGenome}/CCGP/plink/{prefix}_annotated_pruned.vcf.gz"
    output:
        GONE_vcf = "results/{refGenome}/CCGP/plink/{prefix}_GONE_contigs.vcf.gz",
    conda:
        "envs/roh.yml"
    shell:
        '''
        bcftools view -t $(cat {input.chrom_names} | tr '\n' ',') -Oz -o {output.GONE_vcf} {input.vcf_ap}
        '''

rule SNP_check:
    input:
        GONE_vcf = "results/{refGenome}/CCGP/plink/{prefix}_GONE_contigs.vcf.gz"
    output:
        snp_positions = "results/{refGenome}/CCGP/plink/{prefix}_snp_positions.txt",
        GONE_csi = "results/{refGenome}/CCGP/plink/{prefix}_GONE_contigs.vcf.gz.csi"

    conda:
        "envs/roh.yml"
    shell:
        '''
        bcftools query -f '%CHROM\t%POS\t%REF\n' {input.GONE_vcf} | awk 'length($3) == 1 {{print $1"\t"$2}}' > {output.snp_positions}
        bcftools index {input.GONE_vcf}
        '''

rule SNP_vcf:
    input:
        snp_positions = "results/{refGenome}/CCGP/plink/{prefix}_snp_positions.txt",
        GONE_vcf = "results/{refGenome}/CCGP/plink/{prefix}_GONE_contigs.vcf.gz"
    output:
        indel_phobic_vcf = "results/{refGenome}/CCGP/plink/{prefix}_snp_annotated_pruned.vcf.gz",
    conda:
        "envs/roh.yml"
    shell:
        '''
        bcftools view -R {input.snp_positions} {input.GONE_vcf} -Oz -o {output.indel_phobic_vcf}
        '''

rule plink_bed:
    '''
    Makes initial map and ped files from GONE_contigs vcf.
    '''
    input:
        #GONE_vcf = "results/{refGenome}/CCGP/plink/{prefix}_GONE_contigs.vcf.gz",
        indel_phobic_vcf = "results/{refGenome}/CCGP/plink/{prefix}_snp_annotated_pruned.vcf.gz",
    output:
        plink_bed = "results/{refGenome}/CCGP/plink/{prefix}_plink.bed"
    params:
        plink_out = "results/{refGenome}/CCGP/plink/{prefix}_plink"
    conda:
        "envs/plink1_9.yml"
    shell:
        '''
        plink --vcf {input.indel_phobic_vcf} --out {params.plink_out} --double-id --make-bed --allow-extra-chr
        '''

        
rule plink_map:
    '''
    Generates map and ped files, but renames the map file so it can be modified in rule "rename_chrom_plink". Temporary map file will be used in next rule to rename chromosomes 1-n.
    '''
    input:
        #plink_done = "results/{refGenome}/CCGP/plink/{prefix}_plink_done.txt",
        plink_bed = "results/{refGenome}/CCGP/plink/{prefix}_plink.bed"
    output:
        #plink_map_done = "results/{refGenome}/CCGP/plink/{prefix}_plink_map_done.txt",
        plink_map_temp = "results/{refGenome}/CCGP/plink/{prefix}_plink_ORIG.map"
    params:
        plink_out = "results/{refGenome}/CCGP/plink/{prefix}_plink"
    conda:
        "envs/plink1_9.yml"
    shell:
        '''
        plink --bfile {params.plink_out} --recode --out {params.plink_out} --allow-extra-chr
        mv {params.plink_out}.map {output.plink_map_temp}
        '''


rule rename_chrom_plink:
    '''
    Renames chromosomes 1-n. This is necessary for GONE to execute properly. Confirmed same number of lines in ORIG.map and .map.
    '''
    input:
        map_temp = "results/{refGenome}/CCGP/plink/{prefix}_plink_ORIG.map",
        #plink_map_done = "results/{refGenome}/CCGP/plink/{prefix}_plink_map_done.txt",
    output:
        mapp = "results/{refGenome}/CCGP/plink/{prefix}_plink.map",
    params:
        fai = "results/{refGenome}/data/genome/{refGenome}.fna.fai"
    script:
        "scripts/rename_map.py"
        
    

rule get_GONE:
    input:
        mapp = "results/{refGenome}/CCGP/plink/{prefix}_plink.map",
    output:
        map_GONE = "results/{refGenome}/GONE/Linux/{prefix}_plink.map",
        ped_GONE = "results/{refGenome}/GONE/Linux/{prefix}_plink.ped",
        #GONE_dir = "/scratch2/erik/CCGP-reruns/projects/{prefix}/results/{refGenome}/GONE/Linux/GONE_script.sh"
        #GONE_downloaded = "results/{refGenome}/CCGP/plink/{prefix}_downloaded_GONE.txt"
    params:
        GONE_dwn_dir = "/scratch2/erik/CCGP-reruns/projects/{prefix}/results/{refGenome}",
        map_dir = "/scratch2/erik/CCGP-reruns/projects/{prefix}/results/{refGenome}/CCGP/plink/{prefix}_plink.map",
        ped_dir = "/scratch2/erik/CCGP-reruns/projects/{prefix}/results/{refGenome}/CCGP/plink/{prefix}_plink.ped",
        GONE_dir = "/scratch2/erik/CCGP-reruns/projects/{prefix}/results/{refGenome}/GONE/Linux"

    shell:
        '''
        if [ -f {params.GONE_dwn_dir}/GONE/Linux/GONE_script.sh ]; then
            echo "Directory {params.GONE_dwn_dir}/GONE/Linux/GONE_script.sh already exists."
        else
            echo "Directory {params.GONE_dwn_dir}/GONE/Linux/GONE_script.sh does not exist. Cloning the GONE repository."
            rm -rf {params.GONE_dwn_dir}/GONE/
            git clone https://github.com/esrud/GONE.git {params.GONE_dwn_dir}/GONE
            chmod -R +x {params.GONE_dwn_dir}/GONE
        fi
        cp {params.map_dir} {params.GONE_dir}
        cp {params.ped_dir} {params.GONE_dir}
        '''

rule run_GONE:
    input:
        map_GONE = "results/{refGenome}/GONE/Linux/{prefix}_plink.map",
        ped_GONE = "results/{refGenome}/GONE/Linux/{prefix}_plink.ped",
        #GONE_downloaded = "results/{refGenome}/CCGP/plink/{prefix}_downloaded_GONE.txt"
    output:
        GONE_out_d2 = "results/{refGenome}/GONE/Linux/Output_d2_{prefix}_plink",
        GONE_out_Ne = "results/{refGenome}/GONE/Linux/Output_Ne_{prefix}_plink",
        GONE_output = "results/{refGenome}/GONE/Linux/OUTPUT_{prefix}_plink",
    params:
        GONE_dir = "/scratch2/erik/CCGP-reruns/projects/{prefix}/results/{refGenome}/GONE/Linux",
        parent_dir = "/scratch2/erik/CCGP-reruns",
        ccgp_id = '{prefix}_plink'
    shell:
        '''
        cd {params.GONE_dir} 
        bash script_GONE.sh {params.ccgp_id}
        '''
